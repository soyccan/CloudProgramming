apiVersion: v1
kind: Pod
metadata:
  name: chord-leader
  labels:
    app.kubernetes.io/name: chord
spec:
  # set hostname & subdomain to make this pod discoverable by FQDN
  # (leader.chord.my-namespace.svc.cluster.local)
  # also require a headless service
  hostname: leader
  subdomain: chord
  initContainers:
    # ensure network is setup before running chord container
  - name: noop
    image: alpine
  containers:
  - name: chord
    image: ${REGISTRY_URL}/chord:latest
    ports:
    - containerPort: 5057
      name: chord
    env:
    - name: CHORD_IP
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
  - name: uploadserver
    image: ${REGISTRY_URL}/uploadserver:latest
    ports:
    - containerPort: 5058
      name: uploadserver
    volumeMounts:
    - mountPath: /files
      name: uploadserver-storage
  - name: init
    image: ${REGISTRY_URL}/init:latest
    env:
    - name: LEADER
      value: "true"
    - name: CHORD_IP
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
    readinessProbe:
      exec:
        command: [ls, /workdir/init.done]
  volumes:
  - name: uploadserver-storage
    persistentVolumeClaim:
      claimName: uploadserver-storage-leader
  securityContext:
    fsGroup: 1000
  affinity:
    # ensure pods land on separate hosts
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values: [chord]
        topologyKey: kubernetes.io/hostname
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: uploadserver-storage-leader
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: chord
spec:
  replicas: 3
  selector:
    matchLabels:
      app.kubernetes.io/name: chord
  template:
    metadata:
      labels:
        app.kubernetes.io/name: chord
    spec:
      initContainers:
        # ensure network is setup before running chord container
      - name: noop
        image: alpine
      containers:
      - name: chord
        image: ${REGISTRY_URL}/chord:latest
        ports:
        - containerPort: 5057
          name: chord
        env:
        - name: CHORD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        livenessProbe:
          tcpSocket:
            port: chord
        readinessProbe:
          tcpSocket:
            port: chord
      - name: uploadserver
        image: ${REGISTRY_URL}/uploadserver:latest
        ports:
        - containerPort: 5058
          name: uploadserver
        volumeMounts:
        - mountPath: /files
          name: uploadserver-storage
        livenessProbe:
          tcpSocket:
            port: uploadserver
        readinessProbe:
          tcpSocket:
            port: uploadserver
      - name: init
        image: ${REGISTRY_URL}/init:latest
        env:
        - name: CHORD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: CHORD_ID
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        readinessProbe:
          exec:
            command: [ls, /workdir/init.done]
      securityContext:
        fsGroup: 1000
      affinity:
        # ensure pods land on separate hosts
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values: [chord]
            topologyKey: kubernetes.io/hostname
  volumeClaimTemplates:
  - metadata:
      name: uploadserver-storage
    spec:
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: chord
spec:
  selector:
    app.kubernetes.io/name: chord
  clusterIP: None  # headless
  ports:
  - port: 5057
    name: chord
  - port: 5058
    name: uploadserver
---
# TODO: TLS, use NGINX ingress
# apiVersion: networking.k8s.io/v1
# kind: Ingress
# metadata:
#   name: chord
# spec:
#   defaultBackend:
#     service:
#       name: chord
#       port:
#         number:
---
