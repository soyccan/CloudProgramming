apiVersion: v1
kind: Pod
metadata:
  name: chord-leader
  labels:
    app.kubernetes.io/name: chord
spec:
  hostname: leader
  subdomain: chord
  initContainers:
  # ensure network is setup before running chord container
  - name: noop
    image: alpine
  containers:
  - name: chord
    image: ${REGISTRY_URL}/chord:latest
    ports:
    - containerPort: 5057
      name: chord
    env:
    - name: CHORD_IP
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
  - name: uploadserver
    image: ${REGISTRY_URL}/uploadserver:latest
    ports:
    - containerPort: 5058
      name: uploadserver
    volumeMounts:
    - mountPath: /files
      name: uploadserver-storage
  - name: init
    image: ${REGISTRY_URL}/init:latest
    env:
    - name: LEADER
      value: "true"
    - name: CHORD_IP
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
    readinessProbe:
      exec:
        command: [ls, /workdir/init.done]
  volumes:
  - name: uploadserver-storage
    persistentVolumeClaim:
      claimName: uploadserver-storage-claim
  affinity:
    # ensure pods land on separate hosts
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values: [chord]
        topologyKey: kubernetes.io/hostname
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: chord
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: chord
  template:
    metadata:
      labels:
        app.kubernetes.io/name: chord
    spec:
      initContainers:
      # ensure network is setup before running chord container
      - name: noop
        image: alpine
      containers:
      - name: chord
        image: ${REGISTRY_URL}/chord:latest
        ports:
        - containerPort: 5057
          name: chord
        env:
        - name: CHORD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
      - name: uploadserver
        image: ${REGISTRY_URL}/uploadserver:latest
        ports:
        - containerPort: 5058
          name: uploadserver
        volumeMounts:
        - mountPath: /files
          name: uploadserver-storage
      - name: init
        image: ${REGISTRY_URL}/init:latest
        env:
        - name: CHORD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        readinessProbe:
          exec:
            command: [ls, /workdir/init.done]
      volumes:
      - name: uploadserver-storage
        persistentVolumeClaim:
          claimName: uploadserver-storage-claim
      affinity:
        # ensure pods land on separate hosts
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values: [chord]
            topologyKey: kubernetes.io/hostname
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: uploadserver-storage-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: chord
spec:
  selector:
    app.kubernetes.io/name: chord
  clusterIP: None
  ports:
  - port: 5057
---
# TODO: TLS, use NGINX ingress
# apiVersion: networking.k8s.io/v1
# kind: Ingress
# metadata:
#   name: chord
# spec:
#   defaultBackend:
#     service:
#       name: chord
#       port:
#         number:
---
